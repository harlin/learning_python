Вопросы:

1. Как получить список всех атрибутов объекта

2. Как получить список всех публичных атрибутов объекта

3. Как получить список методов объекта

4. В какой "магической" переменной хранится содержимое help?

5. Есть два кортежа, получить третий как сумму первых двух
# если имелось в виду "объединение"
T = tuple( list(tuple1).extend( list(tuple2)) )

6. Есть два кортежа, получить третий как сумму уникальных элементов первых двух кортежей
# если имеется в виду объединение
T = tuple( set( list(tuple1).extend( list(tuple2) ) ) )

7 Почему если в цикле меняется цикл, то используется for x in lst[:], что означает `[:]`?
# Полагаю, имелось в виду, "если в цикле меняется список"
lst[:] возвращает копию lst, таким образом это защищает нас от того, что итератор бежит по изменяющемуся списку
(что может привести, например, к бесконечному циклу если внутри блока есть lst.append)

8. Есть два списка одинаковой длины, в одном ключи, в другом значения. Составить словарь.
D = dict( zip(keys, values) )

9. Есть два списка разной длины, в одном ключи, в другом значения. Составить словарь. Для ключей, для которых нет значений использовать None в качестве значения. Значения, для которых нет ключей игнорировать.
# Не нашел никакого конструктора словаря который умеет что-то подобное по умолчанию
if len(keys) > len(values) :
	values.extend( ['None']*(len(keys) - len(values)) )
else :
	values = values[:len(keys)]
D = dict( zip(keys, values) )

10. Есть словарь. Инвертировать его. Т.е. пары ключ: значение поменять местами -- значение: ключ.
# метод немного небезопасный, т.к. ключи д.б. уникальны, а значения - нет
D = dict( zip(D.values(), D.keys()) )

11. Есть строка в юникоде, получить 8-битную строку в кодировке utf-8 и cp1251

12. Есть строка в кодировке cp1251, получить юникодную строку
U = unicode(st, 'CP1251')
