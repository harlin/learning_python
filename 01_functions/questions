Вопросы:

1. Как получить список всех атрибутов объекта
dir(object)

2. Как получить список всех публичных атрибутов объекта

3. Как получить список методов объекта
# будет с описанием
help(object)

4. В какой "магической" переменной хранится содержимое help?
__doc__

5. Есть два кортежа, получить третий как сумму первых двух
# если имелось в виду "объединение"
result = tuple( list(tuple_1).extend( list(tuple_2)) )

6. Есть два кортежа, получить третий как сумму уникальных элементов первых двух кортежей
# если имеется в виду объединение
result = tuple( set( list(tuple_1).extend( list(tuple_2) ) ) )

7 Почему если в цикле меняется цикл, то используется for x in lst[:], что означает `[:]`?
# Полагаю, имелось в виду, "если в цикле меняется список"
lst[:] возвращает копию lst, таким образом это защищает нас от того, что итератор бежит по изменяющемуся списку
(что может привести, например, к бесконечному циклу если внутри блока есть lst.append)

8. Есть два списка одинаковой длины, в одном ключи, в другом значения. Составить словарь.
result = dict( zip(keys, values) )

9. Есть два списка разной длины, в одном ключи, в другом значения. Составить словарь. Для ключей, для которых нет значений использовать None в качестве значения. Значения, для которых нет ключей игнорировать.
# Не нашел никакого конструктора словаря который умеет что-то подобное по умолчанию
if len(keys) > len(values) :
	values.extend( ['None']*(len(keys) - len(values)) )
else :
	values = values[:len(keys)]
result = dict( zip(keys, values) )

10. Есть словарь. Инвертировать его. Т.е. пары ключ: значение поменять местами -- значение: ключ.
# метод немного небезопасный, т.к. ключи д.б. уникальны, а значения - нет
d = dict( zip(d.values(), d.keys()) )

11. Есть строка в юникоде, получить 8-битную строку в кодировке utf-8 и cp1251
u.encode('UTF-8') 
u.encode('CP1251') # TODO: не уверен что работает как надо

12. Есть строка в кодировке cp1251, получить юникодную строку
u = unicode(st, 'CP1251')
